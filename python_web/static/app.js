(function(){
const statusEl=document.getElementById('status'); const tbody=document.querySelector('#players tbody');
const canvas=document.getElementById('map'); const ctx=canvas.getContext('2d'); let positions={};
function setStatus(t){ statusEl.textContent=t; } function pretty(n,d=1){ return (Math.round(n*10**d)/10**d).toFixed(d); }
function renderTable(){ const now=Date.now()/1000; tbody.innerHTML=''; Object.keys(positions).sort().forEach(n=>{const p=positions[n],age=Math.max(0,now-(p.ts||now)); const tr=document.createElement('tr'); tr.innerHTML=`<td>${n}</td><td>${pretty(p.x)}</td><td>${pretty(p.y)}</td><td>${pretty(p.z)}</td><td>${pretty(age)}</td>`; tbody.appendChild(tr);}); }
function drawCompass(w,h,margin){ const r=36, cx=w - margin/2 - r, cy=margin/2 + r; ctx.strokeStyle='#3a445a'; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke(); ctx.fillStyle='#e5e7eb'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('N', cx, cy-r-12); ctx.fillText('E', cx+r+12, cy); ctx.fillText('S', cx, cy+r+12); ctx.fillText('O', cx-r-12, cy); ctx.strokeStyle='#cbd5e1'; ctx.beginPath(); ctx.moveTo(cx,cy-r); ctx.lineTo(cx,cy-r+10); ctx.moveTo(cx+r-10,cy); ctx.lineTo(cx+r,cy); ctx.moveTo(cx,cy+r-10); ctx.lineTo(cx,cy+r); ctx.moveTo(cx-r,cy); ctx.lineTo(cx-r+10,cy); ctx.stroke(); }
function renderMap(){ const dpr=window.devicePixelRatio||1; if(canvas.width!==canvas.clientWidth*dpr){ canvas.width=canvas.clientWidth*dpr; canvas.height=canvas.clientHeight*dpr; } const w=canvas.clientWidth, h=canvas.clientHeight; ctx.setTransform(dpr,0,0,dpr,0,0); ctx.clearRect(0,0,w,h); const margin=50, plotW=Math.max(10,w-2*margin), plotH=Math.max(10,h-2*margin); ctx.strokeStyle='#3a445a'; ctx.strokeRect(margin,margin,plotW,plotH); ctx.strokeStyle='#202838'; for(let x=margin;x<=margin+plotW+1;x+=40){ ctx.beginPath(); ctx.moveTo(x,margin); ctx.lineTo(x,margin+plotH); ctx.stroke(); } for(let y=margin;y<=margin+plotH+1;y+=40){ ctx.beginPath(); ctx.moveTo(margin,y); ctx.lineTo(margin+plotW,y); ctx.stroke(); } const names=Object.keys(positions); if(names.length===0){ ctx.fillStyle='#cbd5e1'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('En attente de données…', w/2, h/2); drawCompass(w,h,margin); return; } const xs=names.map(n=>positions[n].x), zs=names.map(n=>positions[n].z); let minX=Math.min(...xs), maxX=Math.max(...xs), minZ=Math.min(...zs), maxZ=Math.max(...zs); const padX=Math.max(5,(maxX-minX)*0.1), padZ=Math.max(5,(maxZ-minZ)*0.1); minX-=padX; maxX+=padX; minZ-=padZ; maxZ+=padZ; const spanX=Math.max(1e-6,maxX-minX), spanZ=Math.max(1e-6,maxZ-minZ); const mapX=x=> margin+(x-minX)/spanX*plotW; const mapZ=z=> margin+(maxZ-z)/spanZ*plotH; ctx.setLineDash([3,3]); ctx.strokeStyle='#2b3750'; ctx.beginPath(); ctx.moveTo(margin+plotW/2, margin); ctx.lineTo(margin+plotW/2, margin+plotH); ctx.moveTo(margin, margin+plotH/2); ctx.lineTo(margin+plotW, margin+plotH/2); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle='#9aa1af'; ctx.textAlign='center'; ctx.textBaseline='bottom'; ctx.fillText('X (est/ouest)', margin+plotW/2, margin-8); ctx.save(); ctx.translate(margin-12, margin+plotH/2); ctx.rotate(-Math.PI/2); ctx.fillText('Z (nord/sud)', 0, 0); ctx.restore(); names.sort().forEach(name=>{ const p=positions[name], cx=mapX(p.x), cz=mapZ(p.z); ctx.fillStyle='#00d3ff'; ctx.beginPath(); ctx.arc(cx,cz,5,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#e5e7eb'; ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillText(`${name} (${Math.round(p.x)},${Math.round(p.z)})`, cx+8, cz); }); ctx.fillStyle='#9aa1af'; ctx.textAlign='left'; ctx.textBaseline='top'; ctx.fillText(`X: ${Math.round(minX)} .. ${Math.round(maxX)}`, margin, h-margin+6); ctx.textAlign='right'; ctx.textBaseline='bottom'; ctx.fillText(`Z: ${Math.round(maxZ)} .. ${Math.round(minZ)}`, w-margin, margin-6); drawCompass(w,h,margin); }
function updateAll(){ renderTable(); renderMap(); }
if('EventSource' in window){ const es=new EventSource('/stream'); es.addEventListener('open', ()=>setStatus('Connecté (SSE).')); es.addEventListener('error', ()=>setStatus('SSE en erreur, reconnexion…')); es.addEventListener('positions', ev=>{ try{ const obj=JSON.parse(ev.data); if(obj&&obj.data){ positions=obj.data; updateAll(); } }catch(e){} }); } else { setStatus('SSE non supporté, polling 3s…'); async function tick(){ try{ const r=await fetch('/api/positions',{cache:'no-store'}); positions=await r.json(); updateAll(); }catch(e){} setTimeout(tick,3000);} tick(); } window.addEventListener('resize', renderMap); updateAll();
})();